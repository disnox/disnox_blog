---
slug: /thread_pool1
title: å•å‘é“¾è¡¨åˆ›å»ºçº¿ç¨‹æ± 
date: 2022-12-16
authors: disnox
tags: [C/C++, Linux]
keywords: [C/C++, Linux]
description: å•å‘é“¾è¡¨åˆ›å»ºçº¿ç¨‹æ± 
image: /img/blog/blog.png
sticky: 3
---

ä½¿ç”¨å•å‘é“¾è¡¨å®ç°çº¿ç¨‹æ± çš„æ¥å£è®¾è®¡

<!-- truncate -->

## 1. åŸºç¡€çŸ¥è¯†

å…³äºé“¾è¡¨å’Œçº¿ç¨‹çš„ä½¿ç”¨æ–¹æ³•å¯ä»¥æŸ¥çœ‹æˆ‘çš„æŠ€æœ¯ç¬”è®°ï¼š[æ•°æ®ç»“æ„](https://www.disnox.top/docs/category/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84) å’Œ [ç³»ç»Ÿç¼–ç¨‹](https://www.disnox.top/docs/category/linux-%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B) ï¼Œåœ¨è¿™ä¸¤ä¸ªé¡µé¢éƒ½å¯ä»¥æ‰¾åˆ°é“¾è¡¨å’Œçº¿ç¨‹çš„ä¸€äº›åŸºç¡€çŸ¥è¯†å’Œä½¿ç”¨ç¤ºä¾‹ã€‚

åœ¨ Linux ç³»ç»Ÿä¸­ï¼Œçº¿ç¨‹æ± æ˜¯ä¸€ç§ç”¨äºç®¡ç†å’Œè°ƒåº¦çº¿ç¨‹çš„æœºåˆ¶ã€‚å®ƒç”±ä¸€ç»„å¯ä»¥å¤ç”¨çš„çº¿ç¨‹ç»„æˆï¼Œè¿™äº›çº¿ç¨‹è¢«ä¿å­˜åœ¨çº¿ç¨‹æ± ä¸­ï¼Œå¹¶ç­‰å¾…åˆ†é…ä»»åŠ¡ã€‚

å½“ä¸€ä¸ªæ–°çš„ä»»åŠ¡åˆ°è¾¾æ—¶ï¼Œçº¿ç¨‹æ± ä¼šä»å…¶ä¸­é€‰æ‹©ä¸€ä¸ªçº¿ç¨‹æ¥æ‰§è¡Œè¯¥ä»»åŠ¡ã€‚å¦‚æœæ‰€æœ‰çº¿ç¨‹éƒ½æ­£åœ¨æ‰§è¡Œä»»åŠ¡ï¼Œåˆ™æ–°ä»»åŠ¡å°†è¢«æ”¾åœ¨é˜Ÿåˆ—ä¸­ç­‰å¾…ï¼Œç›´åˆ°æœ‰çº¿ç¨‹å¯ç”¨ã€‚

ä½¿ç”¨çº¿ç¨‹æ± çš„ä¼˜ç‚¹åŒ…æ‹¬ï¼š

- å¯ä»¥æ›´æœ‰æ•ˆåœ°åˆ©ç”¨ CPU èµ„æºï¼Œå› ä¸ºçº¿ç¨‹å¯ä»¥åœ¨ä»»åŠ¡ä¹‹é—´å¤ç”¨ã€‚
- å¯ä»¥æ›´å®¹æ˜“åœ°ç®¡ç†çº¿ç¨‹ï¼Œå› ä¸ºæ‰€æœ‰çº¿ç¨‹éƒ½åœ¨çº¿ç¨‹æ± ä¸­ã€‚
- å¯ä»¥æ›´å®¹æ˜“åœ°ç»´æŠ¤çº¿ç¨‹çš„æ•°é‡ï¼Œå› ä¸ºå¯ä»¥é™åˆ¶çº¿ç¨‹æ± çš„å¤§å°ã€‚

çº¿ç¨‹æ± çš„å®ç°åŸç†å¯ä»¥å‚è€ƒè¿™ç¯‡ç¬”è®°ï¼š[çº¿ç¨‹æ± ](https://www.disnox.top/docs/thread_pool)ã€‚

ä¸‹é¢æˆ‘ä»¬æ¥çœ‹çœ‹æ€ä¹ˆé€šè¿‡å•å‘é“¾è¡¨è·Ÿçº¿ç¨‹çš„ç»„åˆå®ç°çº¿ç¨‹æ± ã€‚

## 2. çº¿ç¨‹æ± æ¥å£è®¾è®¡

### 2.1 ä»»åŠ¡ç»“æ„ä½“

+ æ¥å£æ–‡æ¡£

| åŸå‹     | struct task                                                  |
| -------- | ------------------------------------------------------------ |
| åŠŸèƒ½æè¿° | ä»»åŠ¡èŠ‚ç‚¹ï¼ŒåŒ…å«éœ€è¦æ‰§è¡Œçš„å‡½æ•°åŠå…¶å‚æ•°ï¼Œé€šè¿‡é“¾è¡¨è¿æˆä¸€ä¸ªä»»åŠ¡é˜Ÿåˆ— |
| æˆå‘˜åˆ—è¡¨ | ***void \*(\*task)(void \*arg);<br/>void \*arg;<br/>struct task \*next;*** |
| å¤‡æ³¨     | ä»»åŠ¡é˜Ÿåˆ—æœ€ç»ˆæ˜¯å½¢æˆä¸€æ¡å•å‘é“¾è¡¨                               |

+ ä»£ç å®ç°

```jsx showLineNumbers
struct task {	// ä»»åŠ¡èŠ‚ç‚¹
	void *(*task)(void *arg);
	void *arg;
	struct task *next;
};
```

### 2.2 çº¿ç¨‹æ± ç»“æ„ä½“

+ æ¥å£æ–‡æ¡£

| åŸå‹     | thread_pool                                                  |
| :------- | :----------------------------------------------------------- |
| åŠŸèƒ½æè¿° | åŒ…å«çº¿ç¨‹æ± çš„æ‰€æœ‰ä¿¡æ¯                                         |
| æˆå‘˜åˆ—è¡¨ | ***pthread_mutex_t lock;	// äº’æ–¥é”ï¼Œä¿æŠ¤ä»»åŠ¡é˜Ÿåˆ—<br/>pthread_cond_t  cond;	// æ¡ä»¶å˜é‡ï¼ŒåŒæ­¥æ‰€æœ‰çº¿ç¨‹<br/>struct task \*task_list;	  // ä»»åŠ¡é“¾é˜Ÿåˆ—æŒ‡é’ˆ<br/>pthread_t \*tids;		      // çº¿ç¨‹IDå­˜æ”¾ä½ç½®<br/>unsigned waiting_tasks;	// ä»»åŠ¡é“¾é˜Ÿåˆ—ä¸­ç­‰å¾…çš„ä»»åŠ¡ä¸ªæ•°<br/>unsigned active_threads;// å½“å‰æ´»è·ƒçº¿ç¨‹ä¸ªæ•°<br/>bool shutdown;			// çº¿ç¨‹æ± é”€æ¯æ ‡è®°*** |
| å¤‡æ³¨     | æ´»è·ƒçº¿ç¨‹ä¸ªæ•°ç”±ç”¨æˆ·è‡ªè¡Œå®šä¹‰ï¼Œä½†è‡³å°‘åŒ…å«ä¸€æ¡æ´»è·ƒçº¿ç¨‹           |

+ ä»£ç å®ç°

```jsx showLineNumbers
typedef struct thread_pool {// çº¿ç¨‹æ± 
	pthread_mutex_t lock;	// äº’æ–¥é”ï¼Œä¿æŠ¤ä»»åŠ¡é˜Ÿåˆ—
	pthread_cond_t  cond;	// æ¡ä»¶å˜é‡ï¼ŒåŒæ­¥æ‰€æœ‰çº¿ç¨‹
	struct task *task_list;	// ä»»åŠ¡é“¾é˜Ÿåˆ—æŒ‡é’ˆ
	pthread_t *tids;		// çº¿ç¨‹IDå­˜æ”¾ä½ç½®
	unsigned waiting_tasks;	// ä»»åŠ¡é“¾é˜Ÿåˆ—ä¸­ç­‰å¾…çš„ä»»åŠ¡ä¸ªæ•°
	unsigned active_threads;// å½“å‰æ´»è·ƒçº¿ç¨‹ä¸ªæ•°
	bool shutdown;			// çº¿ç¨‹æ± é”€æ¯æ ‡è®°
}thread_pool;
```

### 2.3 çº¿ç¨‹æ± åˆå§‹åŒ–

+ æ¥å£æ–‡æ¡£

| åŸå‹       | bool init_pool(thread_pool* pool, unsigned int threads_number); |
| :--------- | :----------------------------------------------------------- |
| åŠŸèƒ½æè¿°   | åˆ›å»ºä¸€ä¸ªæ–°çš„çº¿ç¨‹æ± ï¼ŒåŒ…å«threads_numberä¸ªæ´»è·ƒçº¿ç¨‹             |
| å‚æ•°       | pool: çº¿ç¨‹æ± æŒ‡é’ˆ<br/>threads_number: åˆå§‹æ´»è·ƒçº¿ç¨‹ä¸ªæ•°(å¤§äºç­‰äº1) |
| è¿”å›å€¼     | æˆåŠŸè¿”å› true ï¼Œå¤±è´¥è¿”å› false                               |
| æ‰€åœ¨å¤´æ–‡ä»¶ | thread_pool.h                                                |
| å¤‡æ³¨       | çº¿ç¨‹æ± æœ€å°‘çº¿ç¨‹ä¸ªæ•°ä¸º1                                        |

+ ä»£ç å®ç°

```jsx showLineNumbers
bool init_pool(thread_pool *pool, unsigned int threads_number)
{
	pthread_mutex_init(&pool->lock, NULL);	// åˆå§‹åŒ–äº’æ–¥é”
	pthread_cond_init(&pool->cond, NULL);	// åˆå§‹åŒ–æ¡ä»¶å˜é‡

	pool->shutdown = false;	// åˆå§‹åŒ–çº¿ç¨‹æ± é”€æ¯æ ‡è®°
	pool->task_list = malloc(sizeof(struct task));	// åˆå§‹åŒ–ä»»åŠ¡é˜Ÿåˆ—
	pool->tids = malloc(sizeof(pthread_t) * MAX_ACTIVE_THREADS);	// åˆå§‹åŒ–å­˜æ”¾çº¿ç¨‹IDçš„æ•°ç»„

	if(pool->task_list == NULL || pool->tids == NULL)
	{
		perror("allocate memory error");
		return false;
	}

	pool->task_list->next = NULL;	// é“¾è¡¨çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ä¸ºç©º

	pool->waiting_tasks = 0;	// åˆå§‹åŒ–ä»»åŠ¡é˜Ÿåˆ—ä¸­ç­‰å¾…çš„ä»»åŠ¡ä¸ªæ•°
	pool->active_threads = threads_number;	//åˆå§‹åŒ–æ´»è·ƒçº¿ç¨‹ä¸ªæ•°

	int i;
	// åˆ›å»ºæŒ‡å®šæ•°ç›®çº¿ç¨‹
	for(i=0; i<pool->active_threads; i++) {
		if(pthread_create(&((pool->tids)[i]), NULL, routine, (void *)pool) != 0) {
			perror("create threads error");
			return false;
		}
	}

	return true;
}
```

### 2.4 æŠ•é€ä»»åŠ¡

+ æ¥å£æ–‡æ¡£

| åŸå‹       | bool add_task(thread_pool \*pool, void \*(\*do_task)(void \*arg), void \*arg); |
| :--------- | :----------------------------------------------------------- |
| åŠŸèƒ½æè¿°   | å¾€çº¿ç¨‹æ± æŠ•é€ä»»åŠ¡                                             |
| å‚æ•°       | pool: çº¿ç¨‹æ± æŒ‡é’ˆ<br/>do_task: æŠ•é€è‡³çº¿ç¨‹æ± çš„æ‰§è¡Œä¾‹ç¨‹ <br/>arg: æ‰§è¡Œä¾‹ç¨‹do_taskçš„å‚æ•°ï¼Œè‹¥è¯¥æ‰§è¡Œä¾‹ç¨‹ä¸éœ€è¦å‚æ•°å¯è®¾ç½®ä¸ºNULL |
| è¿”å›å€¼     | æˆåŠŸè¿”å›trueï¼Œå¤±è´¥è¿”å›false                                  |
| æ‰€åœ¨å¤´æ–‡ä»¶ | thread_pool.h                                                |
| å¤‡æ³¨       | ä»»åŠ¡é˜Ÿåˆ—ä¸­æœ€å¤§ä»»åŠ¡ä¸ªæ•°ä¸º MAX_WAITING_TASKS                   |

+ ä»£ç å®ç°

```jsx showLineNumbers
bool add_task(thread_pool *pool, void *(*task)(void *arg), void *arg)
{
	struct task *new_task = malloc(sizeof(struct task));	// æ–°ä»»åŠ¡ç»“ç‚¹

	if(new_task == NULL) {
		perror("allocate memory error");
		return false;
	}

	// åˆå§‹åŒ–ä»»åŠ¡èŠ‚ç‚¹
	new_task->task = task;
	new_task->arg = arg;
	new_task->next = NULL;

	// åŠ é”ã€è¶…è¿‡æœ€å¤§ä»»åŠ¡
	pthread_mutex_lock(&pool->lock);
	if(pool->waiting_tasks >= MAX_WAITING_TASKS) {
		pthread_mutex_unlock(&pool->lock);

		fprintf(stderr, "too many tasks.\n");
		free(new_task);

		return false;
	}
	
	struct task *tmp = pool->task_list;
	while(tmp->next != NULL)
		tmp = tmp->next;

	tmp->next = new_task;	// æ·»åŠ æ–°çš„ä»»åŠ¡ç»“ç‚¹
	pool->waiting_tasks++;

	// é‡Šæ”¾äº’æ–¥é”ï¼Œå¹¶å”¤é†’å…¶ä¸­ä¸€ä¸ªé˜»å¡åœ¨æ¡ä»¶å˜é‡ä¸Šçš„çº¿ç¨‹
	pthread_mutex_unlock(&pool->lock);
	pthread_cond_signal(&pool->cond);

	return true;
}
```

### 2.5 å¢åŠ æ´»è·ƒçº¿ç¨‹

+ æ¥å£æ–‡æ¡£

| åŸå‹       | int add_thread(thread_pool*pool, unsigned int additional_threads); |
| :--------- | :----------------------------------------------------------- |
| åŠŸèƒ½æè¿°   | å¢åŠ çº¿ç¨‹æ± ä¸­æ´»è·ƒçº¿ç¨‹çš„ä¸ªæ•°                                   |
| å‚æ•°       | pool: éœ€è¦å¢åŠ çº¿ç¨‹çš„çº¿ç¨‹æ± æŒ‡é’ˆ<br/>additional_threads: æ–°å¢çº¿ç¨‹ä¸ªæ•° |
| è¿”å›å€¼     | >0: å®é™…æ–°å¢çº¿ç¨‹ä¸ªæ•°<br/>-1: å¤±è´¥                            |
| æ‰€åœ¨å¤´æ–‡ä»¶ | thread_pool.h                                                |
| å¤‡æ³¨       | å¢åŠ çš„æ´»è·ƒçº¿ç¨‹çš„æ•°é‡å’Œä¹‹å‰åˆå§‹åŒ–çš„çº¿ç¨‹æ•°é‡ä¸èƒ½å¤§äº MAX_ACTIVE_THREADS |

+ ä»£ç å®ç°

```jsx showLineNumbers
int add_thread(thread_pool *pool, unsigned int additional_threads)
{
	if(additional_threads == 0)
		return 0;

	unsigned total_threads = pool->active_threads + additional_threads;

	int i, actual_increment = 0;	// æˆåŠŸåˆ›å»ºçº¿ç¨‹çš„ä¸ªæ•°
	// å¾ªç¯åˆ›å»ºè‹¥å¹²æŒ‡å®šæ•°ç›®çš„çº¿ç¨‹
	for(i=pool->active_threads; i<total_threads && i<MAX_ACTIVE_THREADS; i++) {
		if(pthread_create(&((pool->tids)[i]), NULL, routine, (void *)pool) != 0) {
			perror("add threads error");

			if(actual_increment == 0)
				return -1;

			break;
		}
		actual_increment++; 
	}

	// æ›´æ–°çº¿ç¨‹æ± ä¸­çš„æ´»è·ƒçº¿ç¨‹ä¸ªæ•°
	pool->active_threads += actual_increment;

	return actual_increment;
}
```

### 2.6 åˆ é™¤çº¿ç¨‹

+ æ¥å£æ–‡æ¡£

| åŸå‹       | int remove_thread(thread_pool*pool, unsigned int removing_threads); |
| :--------- | :----------------------------------------------------------- |
| åŠŸèƒ½æè¿°   | åˆ é™¤çº¿ç¨‹æ± ä¸­æ´»è·ƒçº¿ç¨‹çš„ä¸ªæ•°                                   |
| å‚æ•°       | pool: éœ€è¦åˆ é™¤çº¿ç¨‹çš„çº¿ç¨‹æ± æŒ‡é’ˆ<br/>removing_threads: è¦åˆ é™¤çš„çº¿ç¨‹ä¸ªæ•°ï¼Œè¯¥å‚æ•°è®¾ç½®ä¸º0æ—¶ç›´æ¥è¿”å›å½“å‰çº¿ç¨‹æ± çº¿ç¨‹æ€»æ•°ï¼Œå¯¹çº¿ç¨‹æ± ä¸é€ æˆä»»ä½•å…¶å®ƒå½±å“ |
| è¿”å›å€¼     | >0: å½“å‰çº¿ç¨‹æ± å‰©ä½™çº¿ç¨‹ä¸ªæ•°<br/>-1:å¤±è´¥                       |
| æ‰€åœ¨å¤´æ–‡ä»¶ | thread_pool.h                                                |
| å¤‡æ³¨       | 1ï¼Œçº¿ç¨‹æ± è‡³å°‘ä¼šå­˜åœ¨1æ¡æ´»è·ƒçº¿ç¨‹<br/>2ï¼Œå¦‚æœè¢«åˆ é™¤çš„çº¿ç¨‹æ­£åœ¨æ‰§è¡Œä»»åŠ¡ï¼Œåˆ™å°†ç­‰å¾…å…¶å®Œæˆä»»åŠ¡ä¹‹ååˆ é™¤ |

+ ä»£ç å®ç°

```jsx showLineNumbers
int remove_thread(thread_pool *pool, unsigned int removing_threads)
{
	if(removing_threads == 0)
		return pool->active_threads;
	
	int remain_threads = pool->active_threads - removing_threads;
	remain_threads = remain_threads > 0 ? remain_threads : 1;

	int i;
	// å¾ªç¯åœ°å–æ¶ˆæ‰æŒ‡å®šæ•°ç›®çš„çº¿ç¨‹
	for(i=pool->active_threads-1; i>remain_threads-1; i--) {
		errno = pthread_cancel(pool->tids[i]);
		if(errno != 0)
			break;
	}

	if(i == pool->active_threads-1) {
		return -1;
	} else {
		pool->active_threads = i+1;
		return i+1;
	}

    return 0;
}
```

### 2.7 é”€æ¯çº¿ç¨‹æ± 

+ æ¥å£æ–‡æ¡£

| åŸå‹       | bool destroy_pool(thread_pool \*pool);                       |
| :--------- | :----------------------------------------------------------- |
| åŠŸèƒ½æè¿°   | é˜»å¡ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆï¼Œç„¶åç«‹å³é”€æ¯æ•´ä¸ªçº¿ç¨‹æ± ï¼Œé‡Šæ”¾æ‰€æœ‰èµ„æºå’Œå†…å­˜ |
| å‚æ•°       | pool:å°†è¦é”€æ¯çš„çº¿ç¨‹æ±                                         |
| è¿”å›å€¼     | æˆåŠŸè¿”å›trueï¼Œå¤±è´¥è¿”å›false                                  |
| æ‰€åœ¨å¤´æ–‡ä»¶ | thread_pool.h                                                |
| å¤‡æ³¨       | æ—                                                            |

+ ä»£ç å®ç°

```jsx showLineNumbers
bool destroy_pool(thread_pool *pool)
{
	pool->shutdown = true;	// çº¿ç¨‹æ± çš„é”€æ¯æ ‡è®°
	pthread_cond_broadcast(&pool->cond);	// å”¤é†’æ‰€æœ‰çº¿ç¨‹

	int i;
	// ç­‰å¾…æ‰€æœ‰çº¿ç¨‹é€€å‡º
	for(i=0; i<pool->active_threads; i++) {
		errno = pthread_join(pool->tids[i], NULL);
		if(errno != 0) {
			printf("join tids[%d] error: %s\n", i, strerror(errno));
		} else {
			printf("[%u] is joined\n", (unsigned)pool->tids[i]);
		}
	}

	free(pool->task_list);	// é‡Šæ”¾èµ„æº
	free(pool->tids);		// æ¸…ç©ºä»»åŠ¡é˜Ÿåˆ—
	free(pool);				// é‡Šæ”¾ä»»åŠ¡é˜Ÿåˆ—

	return true;
}
```

### 2.8 çº¿ç¨‹å…¥å£å‡½æ•°

+ ç”¨æ¥æ‰§è¡Œä»»åŠ¡çš„çº¿ç¨‹å‡½æ•°ï¼š

```jsx showLineNumbers
void *routine(void *arg)
{
	thread_pool *pool = (thread_pool *)arg;	//å®šä¹‰çº¿ç¨‹æ± ç»“æ„ä½“æŒ‡é’ˆï¼Œæ‹¿åˆ°çº¿ç¨‹æ± çš„æŒ‡é’ˆ
	struct task *p;	//å®šä¹‰ä»»åŠ¡ç»“æ„ä½“æŒ‡é’ˆï¼Œç”¨æ¥è¡¨ç¤ºæ‹¿åˆ°çš„ä»»åŠ¡

	//ä¸æ–­çš„æ‹¿ä»»åŠ¡ï¼Œæ‰§è¡Œ
	while(1) {
		// è®¿é—®ä»»åŠ¡é˜Ÿåˆ—å‰åŠ é”ï¼Œä¸ºé˜²æ­¢å–æ¶ˆåæ­»é”ï¼Œæ³¨å†Œå¤„ç†ä¾‹ç¨‹ handle
		pthread_cleanup_push(handler, (void *)&pool->lock);	//é˜²æ­¢æ­»é”
		pthread_mutex_lock(&pool->lock);	//åŠ é”

		//å¦‚æœä»»åŠ¡é˜Ÿåˆ—ä¸ºç©ºå¹¶ä¸”çº¿ç¨‹æ± æ²¡æœ‰è¢«é”€æ¯ï¼Œçº¿ç¨‹è¿›å…¥æ¡ä»¶å˜é‡ç­‰å¾…é˜Ÿåˆ—ç¡çœ 
		while(pool->waiting_tasks == 0 && !pool->shutdown) {
			//æ¡ä»¶å˜é‡ç­‰å¾…é˜Ÿåˆ—
			pthread_cond_wait(&pool->cond, &pool->lock);	
		}

		//å¦‚æœä»»åŠ¡ä¸ºç©ºï¼Œçº¿ç¨‹æ± è¢«é”€æ¯ï¼Œåˆ™ç«‹å³é‡Šæ”¾äº’æ–¥é”å¹¶é€€å‡º
		if(pool->waiting_tasks == 0 && pool->shutdown) {
			pthread_mutex_unlock(&pool->lock);
			pthread_exit(NULL);
		}

		//å–èµ°ä¸€ä¸ªä»»åŠ¡
		p = pool->task_list->next;
		pool->task_list->next = p->next;
		pool->waiting_tasks--;	//ä»»åŠ¡æ•°é‡å‡1

		//ä»»åŠ¡å–èµ°ï¼Œè§£é”ï¼Œå¹¶å¼¹æ ˆ handleï¼ˆä½†ä¸æ‰§è¡Œå®ƒï¼‰
		pthread_mutex_unlock(&pool->lock);
		pthread_cleanup_pop(0);

		//æ‰§è¡Œä»»åŠ¡æœŸé—´æ‹’ç»å–æ¶ˆè¯·æ±‚
		pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, NULL);
		(p->task)(p->arg);
		pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL);

		free(p);	//é‡Šæ”¾èµ„æº
	}

	pthread_exit(NULL);
}
```

+ æ³¨å†Œæ­»é”å¤„ç†å‡½æ•°

```jsx showLineNumbers
void handler(void *arg)
{
	// å“åº”å–æ¶ˆè¯·æ±‚ä¹‹åè‡ªåŠ¨å¤„ç†ï¼šé‡Šæ”¾äº’æ–¥é”
	pthread_mutex_unlock((pthread_mutex_t *)arg);
}
```

## 3. ä½¿ç”¨ç¤ºä¾‹

```jsx showLineNumbers
#include <stdio.h>
#include "thread_pool.h"

void *my_task(void *arg)
{
	int n = *(int *)arg;

	printf("[%u][%s] ==> job will be done in %d sec...\n", (unsigned)pthread_self(), __FUNCTION__, n);

	sleep(n);

	printf("[%u][%s] ==> job done!\n", (unsigned)pthread_self(), __FUNCTION__);

	return NULL;

	// pthread_exit(NULL);
}

void *count_time(void *arg)
{
	int i = 0;
	while(1) {
		sleep(1);
		printf("sec: %d\n", ++i);
	}
}

int main(int argc, char *argv[])
{
	pthread_t a;
	pthread_create(&a, NULL, count_time, NULL);

	// 1.åˆå§‹åŒ–ä¸€ä¸ªå¸¦æœ‰2æ¡çº¿ç¨‹çš„çº¿ç¨‹æ± 
	thread_pool *pool = malloc(sizeof(thread_pool));
	init_pool(pool, 1);

	// 2.æŠ•å…¥3ä¸ªä»»åŠ¡
	static int temp1 = 1, temp2 = 2, temp3 = 3, temp4 = 4, temp5 = 5;
	printf("throwing 3 tasks...\n");
	add_task(pool, my_task, (void *)&temp1);
	add_task(pool, my_task, (void *)&temp2);
	add_task(pool, my_task, (void *)&temp3);
  
	// 3.æ˜¾ç¤ºå½“å‰æœ‰å¤šå°‘æ¡çº¿ç¨‹
	printf("current thread number: %d\n", remove_thread(pool, 0));
	// sleep(9);

	// 4.å†æŠ•å…¥2ä¸ªä»»åŠ¡
	printf("throwing another 2 tasks...\n");
	add_task(pool, my_task, (void *)&temp4);
	add_task(pool, my_task, (void *)&temp5);

	// 5.å¢åŠ 2æ¡çº¿ç¨‹
	add_thread(pool, 2);
	sleep(5);

	// 6.åˆ é™¤3æ¡çº¿ç¨‹
	printf("remove 3 threads from the pool...\n");
	printf("current thread number: %d\n", remove_thread(pool, 3));

	// 7.é”€æ¯çº¿ç¨‹æ± 
	destroy_pool(pool);

	return 0;
}
```

## 4. æºç 

æƒ³è¦æºç çš„è¯ï¼Œä¸å¦¨ä¸Šæˆ‘çš„[ğŸGitHub](https://github.com/disnox/pool)çœ‹çœ‹å§ï¼



































