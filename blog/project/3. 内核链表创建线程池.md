---
slug: /thread_pool2
title: å†…æ ¸é“¾è¡¨åˆ›å»ºçº¿ç¨‹æ± 
date: 2022-12-16
authors: disnox
tags: [C/C++, Linux]
keywords: [C/C++, Linux]
description: å†…æ ¸é“¾è¡¨åˆ›å»ºçº¿ç¨‹æ± 
image: /img/blog/blog.png
sticky: 2
---

ä½¿ç”¨å†…æ ¸é“¾è¡¨å®ç°çº¿ç¨‹æ± çš„æ¥å£è®¾è®¡

<!-- truncate -->

## 1. åŸºç¡€çŸ¥è¯†

å…³äºé“¾è¡¨å’Œçº¿ç¨‹çš„ä½¿ç”¨æ–¹æ³•å¯ä»¥æŸ¥çœ‹æˆ‘çš„æŠ€æœ¯ç¬”è®°ï¼š[æ•°æ®ç»“æ„](https://www.disnox.top/docs/category/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84) å’Œ [ç³»ç»Ÿç¼–ç¨‹](https://www.disnox.top/docs/category/linux-%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B) ï¼Œåœ¨è¿™ä¸¤ä¸ªé¡µé¢éƒ½å¯ä»¥æ‰¾åˆ°é“¾è¡¨å’Œçº¿ç¨‹çš„ä¸€äº›åŸºç¡€çŸ¥è¯†å’Œä½¿ç”¨ç¤ºä¾‹ã€‚

åœ¨ Linux ç³»ç»Ÿä¸­ï¼Œçº¿ç¨‹æ± æ˜¯ä¸€ç§ç”¨äºç®¡ç†å’Œè°ƒåº¦çº¿ç¨‹çš„æœºåˆ¶ã€‚å®ƒç”±ä¸€ç»„å¯ä»¥å¤ç”¨çš„çº¿ç¨‹ç»„æˆï¼Œè¿™äº›çº¿ç¨‹è¢«ä¿å­˜åœ¨çº¿ç¨‹æ± ä¸­ï¼Œå¹¶ç­‰å¾…åˆ†é…ä»»åŠ¡ã€‚

å½“ä¸€ä¸ªæ–°çš„ä»»åŠ¡åˆ°è¾¾æ—¶ï¼Œçº¿ç¨‹æ± ä¼šä»å…¶ä¸­é€‰æ‹©ä¸€ä¸ªçº¿ç¨‹æ¥æ‰§è¡Œè¯¥ä»»åŠ¡ã€‚å¦‚æœæ‰€æœ‰çº¿ç¨‹éƒ½æ­£åœ¨æ‰§è¡Œä»»åŠ¡ï¼Œåˆ™æ–°ä»»åŠ¡å°†è¢«æ”¾åœ¨é˜Ÿåˆ—ä¸­ç­‰å¾…ï¼Œç›´åˆ°æœ‰çº¿ç¨‹å¯ç”¨ã€‚

ä½¿ç”¨çº¿ç¨‹æ± çš„ä¼˜ç‚¹åŒ…æ‹¬ï¼š

- å¯ä»¥æ›´æœ‰æ•ˆåœ°åˆ©ç”¨ CPU èµ„æºï¼Œå› ä¸ºçº¿ç¨‹å¯ä»¥åœ¨ä»»åŠ¡ä¹‹é—´å¤ç”¨ã€‚
- å¯ä»¥æ›´å®¹æ˜“åœ°ç®¡ç†çº¿ç¨‹ï¼Œå› ä¸ºæ‰€æœ‰çº¿ç¨‹éƒ½åœ¨çº¿ç¨‹æ± ä¸­ã€‚
- å¯ä»¥æ›´å®¹æ˜“åœ°ç»´æŠ¤çº¿ç¨‹çš„æ•°é‡ï¼Œå› ä¸ºå¯ä»¥é™åˆ¶çº¿ç¨‹æ± çš„å¤§å°ã€‚

çº¿ç¨‹æ± çš„å®ç°åŸç†å¯ä»¥å‚è€ƒè¿™ç¯‡ç¬”è®°ï¼š[çº¿ç¨‹æ± ](https://www.disnox.top/docs/thread_pool)ã€‚

å†…æ ¸é“¾è¡¨çš„ä½¿ç”¨æ–¹æ³•å¯ä»¥å‚è€ƒè¿™ç¯‡ç¬”è®°ï¼š[å†…æ ¸é“¾è¡¨](https://www.disnox.top/docs/inline_list)ã€‚

ä¸‹é¢æˆ‘ä»¬æ¥çœ‹çœ‹æ€ä¹ˆé€šè¿‡å†…æ ¸é“¾è¡¨è·Ÿçº¿ç¨‹çš„ç»„åˆå®ç°çº¿ç¨‹æ± ã€‚

## 2. çº¿ç¨‹æ± æ¥å£è®¾è®¡

### 2.1 çº¿ç¨‹ç»“æ„ä½“

+ æ¥å£æ–‡æ¡£

| åŸå‹     | struct thread                                                |
| -------- | ------------------------------------------------------------ |
| åŠŸèƒ½æè¿° | çº¿ç¨‹èŠ‚ç‚¹ï¼ŒåŒ…å«çº¿ç¨‹IDï¼Œé€šè¿‡å†…æ ¸é“¾è¡¨è¿æˆä¸€ä¸ªçº¿ç¨‹é˜Ÿåˆ—ï¼Œæ–¹ä¾¿åç»­è¿›è¡Œæ‰©å±• |
| æˆå‘˜åˆ—è¡¨ | ***pthread_t id;           // çº¿ç¨‹ ID<br/>struct list_head list;  // å°ç»“æ„ä½“*** |
| å¤‡æ³¨     | çº¿ç¨‹é˜Ÿåˆ—æœ€ç»ˆæ˜¯å½¢æˆä¸€æ¡å†…æ ¸é“¾è¡¨                               |

+ ä»£ç å®ç°

```jsx showLineNumbers
// çº¿ç¨‹æ± ä¸­çš„çº¿ç¨‹
struct thread {
    pthread_t id;           // çº¿ç¨‹ ID
    struct list_head list;  // å°ç»“æ„ä½“
};
```

### 2.2 ä»»åŠ¡ç»“æ„ä½“

+ æ¥å£æ–‡æ¡£

| åŸå‹     | struct task                                                  |
| -------- | ------------------------------------------------------------ |
| åŠŸèƒ½æè¿° | ä»»åŠ¡èŠ‚ç‚¹ï¼ŒåŒ…å«éœ€è¦æ‰§è¡Œçš„å‡½æ•°åŠå…¶å‚æ•°ï¼Œé€šè¿‡é“¾è¡¨è¿æˆä¸€ä¸ªä»»åŠ¡é˜Ÿåˆ— |
| æˆå‘˜åˆ—è¡¨ | ***void \*(\*func)(void \*arg);<br/>void \*arg;<br/>struct list_head list;*** |
| å¤‡æ³¨     | ä»»åŠ¡é˜Ÿåˆ—æœ€ç»ˆæ˜¯å½¢æˆä¸€æ¡å†…æ ¸é“¾è¡¨                               |

+ ä»£ç å®ç°

```jsx showLineNumbers
// çº¿ç¨‹æ± ä¸­çš„ä»»åŠ¡
struct task {
    void *(*func)(void *);   	// ä»»åŠ¡å‡½æ•°
    void *arg;              	// ä»»åŠ¡å‡½æ•°çš„å‚æ•°
    struct list_head list;  	// å°ç»“æ„ä½“
};
```

### 2.3 çº¿ç¨‹æ± ç»“æ„ä½“

+ æ¥å£æ–‡æ¡£

| åŸå‹     | thread_pool                                                  |
| :------- | :----------------------------------------------------------- |
| åŠŸèƒ½æè¿° | åŒ…å«çº¿ç¨‹æ± çš„æ‰€æœ‰ä¿¡æ¯                                         |
| æˆå‘˜åˆ—è¡¨ | ***struct list_head threads;  	// çº¿ç¨‹é˜Ÿåˆ—<br/>struct list_head queue;  	// ä»»åŠ¡é˜Ÿåˆ—<br/>pthread_mutex_t lock;   	// äº’æ–¥é”<br/>pthread_cond_t cond;     	// æ¡ä»¶å˜é‡<br/>unsigned active_threads;	// çº¿ç¨‹é˜Ÿåˆ—ä¸­çš„çº¿ç¨‹æ•°é‡<br/>unsigned waiting_tasks;		// ä»»åŠ¡é“¾é˜Ÿåˆ—ä¸­ç­‰å¾…çš„ä»»åŠ¡ä¸ªæ•°<br/>bool shutdown;				// çº¿ç¨‹æ± é”€æ¯æ ‡è®°*** |
| å¤‡æ³¨     | æ´»è·ƒçº¿ç¨‹ä¸ªæ•°ç”±ç”¨æˆ·è‡ªè¡Œå®šä¹‰ï¼Œä½†è‡³å°‘åŒ…å«ä¸€æ¡æ´»è·ƒçº¿ç¨‹           |

+ ä»£ç å®ç°

```jsx showLineNumbers
struct thread_pool {
    struct list_head threads;  	// çº¿ç¨‹é˜Ÿåˆ—
    struct list_head queue;  	// ä»»åŠ¡é˜Ÿåˆ—
    pthread_mutex_t lock;   	// äº’æ–¥é”
    pthread_cond_t cond;     	// æ¡ä»¶å˜é‡
	unsigned active_threads;	// çº¿ç¨‹é˜Ÿåˆ—ä¸­çš„çº¿ç¨‹æ•°é‡
	unsigned waiting_tasks;		// ä»»åŠ¡é“¾é˜Ÿåˆ—ä¸­ç­‰å¾…çš„ä»»åŠ¡ä¸ªæ•°
	bool shutdown;				// çº¿ç¨‹æ± é”€æ¯æ ‡è®°
};
```

### 2.4 çº¿ç¨‹æ± åˆå§‹åŒ–

+ æ¥å£æ–‡æ¡£

| åŸå‹       | void thread_pool_init(struct thread_pool *pool, int num_threads) |
| :--------- | :----------------------------------------------------------- |
| åŠŸèƒ½æè¿°   | åˆ›å»ºä¸€ä¸ªæ–°çš„çº¿ç¨‹æ± ï¼ŒåŒ…å« num_threads ä¸ªæ´»è·ƒçº¿ç¨‹              |
| å‚æ•°       | pool: çº¿ç¨‹æ± æŒ‡é’ˆ<br/>num_threads: åˆå§‹æ´»è·ƒçº¿ç¨‹ä¸ªæ•°(å¤§äºç­‰äº1) |
| è¿”å›å€¼     | æ—                                                            |
| æ‰€åœ¨å¤´æ–‡ä»¶ | thread_pool.h                                                |
| å¤‡æ³¨       | çº¿ç¨‹æ± æœ€å°‘çº¿ç¨‹ä¸ªæ•°ä¸º1ï¼Œæœ€å¤§å€¼ä¸è¶…è¿‡ MAX_ACTIVE_THREADS       |

+ ä»£ç å®ç°

```jsx showLineNumbers
void thread_pool_init(struct thread_pool *pool, int num_threads)
{
    int i;

    // æ£€æŸ¥ num_threads çš„å€¼æ˜¯å¦è¶…è¿‡äº†æœ€å¤§å€¼
    if (num_threads > MAX_ACTIVE_THREADS) {
        num_threads = MAX_ACTIVE_THREADS;
    }

	pool->waiting_tasks = 0;				//åˆå§‹åŒ–ä»»åŠ¡é˜Ÿåˆ—ä¸­ç­‰å¾…çš„ä»»åŠ¡ä¸ªæ•°
	pool->active_threads = num_threads;		//åˆå§‹åŒ–æ´»è·ƒçº¿ç¨‹ä¸ªæ•°
	pool->shutdown = false;					//åˆå§‹åŒ–çº¿ç¨‹æ± é”€æ¯æ ‡è®°

    INIT_LIST_HEAD(&pool->threads);	// åˆå§‹åŒ–çº¿ç¨‹é˜Ÿåˆ—
    INIT_LIST_HEAD(&pool->queue);	// åˆå§‹åŒ–ä»»åŠ¡é˜Ÿåˆ—

	// æ˜¯å¦åˆå§‹åŒ–æˆåŠŸ
	if (!list_empty(&pool->queue) || !list_empty(&pool->threads)) {
		fprintf(stderr, "init fail.\n");
		exit(1);
	}

    pthread_mutex_init(&pool->lock, NULL);
    pthread_cond_init(&pool->cond, NULL);

    // åˆ›å»ºçº¿ç¨‹æ± ä¸­çš„çº¿ç¨‹
    for (i = 0; i < num_threads; i++) {
        struct thread *thread = (struct thread *)malloc(sizeof(struct thread));

        INIT_LIST_HEAD(&thread->list);
        // ä½¿ç”¨ pthread_create åˆ›å»ºçº¿ç¨‹
        int ret = pthread_create(&thread->id, NULL, thread_pool_main, pool);
		if (ret != 0) {
			perror("create threads error");
			exit(1);
		}

        // å°†æ–°åˆ›å»ºçš„çº¿ç¨‹æ·»åŠ åˆ°çº¿ç¨‹æ± ä¸­
        list_add_tail(&thread->list, &pool->threads);
    }
}
```

### 2.5 æŠ•é€ä»»åŠ¡

+ æ¥å£æ–‡æ¡£

| åŸå‹       | void thread_pool_add_task(struct thread_pool \*pool, void \*(\*func)(void \*), void \*arg) |
| :--------- | :----------------------------------------------------------- |
| åŠŸèƒ½æè¿°   | å¾€çº¿ç¨‹æ± æŠ•é€ä»»åŠ¡                                             |
| å‚æ•°       | pool: çº¿ç¨‹æ± æŒ‡é’ˆ<br/>func: æŠ•é€è‡³çº¿ç¨‹æ± çš„æ‰§è¡Œä¾‹ç¨‹ <br/>arg: æ‰§è¡Œä¾‹ç¨‹ func çš„å‚æ•°ï¼Œè‹¥è¯¥æ‰§è¡Œä¾‹ç¨‹ä¸éœ€è¦å‚æ•°å¯è®¾ç½®ä¸ºNULL |
| è¿”å›å€¼     | æ—                                                            |
| æ‰€åœ¨å¤´æ–‡ä»¶ | thread_pool.h                                                |
| å¤‡æ³¨       | ä»»åŠ¡é˜Ÿåˆ—ä¸­æœ€å¤§ä»»åŠ¡ä¸ªæ•°ä¸º MAX_WAITING_TASKS                   |

+ ä»£ç å®ç°

```jsx showLineNumbers
void thread_pool_add_task(struct thread_pool *pool, void *(*func)(void *), void *arg)
{
    // åˆ†é…å†…å­˜ç»™æ–°ä»»åŠ¡
    struct task *new_task = (struct task *) malloc(sizeof(struct task));

	if(new_task == NULL) {
		perror("allocate memory error");
		exit(1);
	}

	// åˆå§‹åŒ–ä»»åŠ¡èŠ‚ç‚¹
    new_task->func = func;
    new_task->arg = arg;

    // è·å–é”
    pthread_mutex_lock(&pool->lock);
	// è¶…è¿‡æœ€å¤§ä»»åŠ¡

	if(pool->waiting_tasks >= MAX_WAITING_TASKS) {
		pthread_mutex_unlock(&pool->lock);

		fprintf(stderr, "too many tasks.\n");
		free(new_task);

		exit(1);
	}

    // å°†æ–°ä»»åŠ¡æ·»åŠ åˆ°ä»»åŠ¡é˜Ÿåˆ—çš„æœ«å°¾
    list_add_tail(&new_task->list, &pool->queue);

	// æ–°ä»»åŠ¡åŠ ä¸€
	pool->waiting_tasks++;

    // å”¤é†’ä¸€ä¸ªçº¿ç¨‹ï¼Œè®©å®ƒå¼€å§‹æ‰§è¡Œæ–°ä»»åŠ¡
    pthread_cond_signal(&pool->cond);

    // é‡Šæ”¾é”
    pthread_mutex_unlock(&pool->lock);
}
```

### 2.6 å¢åŠ æ´»è·ƒçº¿ç¨‹

+ æ¥å£æ–‡æ¡£

| åŸå‹       | void thread_pool_add_thread(struct thread_pool \*pool, int num_threads) |
| :--------- | :----------------------------------------------------------- |
| åŠŸèƒ½æè¿°   | å¢åŠ çº¿ç¨‹æ± ä¸­æ´»è·ƒçº¿ç¨‹çš„ä¸ªæ•°                                   |
| å‚æ•°       | pool: éœ€è¦å¢åŠ çº¿ç¨‹çš„çº¿ç¨‹æ± æŒ‡é’ˆ<br/>num_threads: æ–°å¢çº¿ç¨‹ä¸ªæ•° |
| è¿”å›å€¼     | æ—                                                            |
| æ‰€åœ¨å¤´æ–‡ä»¶ | thread_pool.h                                                |
| å¤‡æ³¨       | å¢åŠ çš„æ´»è·ƒçº¿ç¨‹çš„æ•°é‡å’Œä¹‹å‰åˆå§‹åŒ–çš„çº¿ç¨‹æ•°é‡ä¸èƒ½å¤§äº MAX_ACTIVE_THREADS |

+ ä»£ç å®ç°

```jsx showLineNumbers
void thread_pool_add_thread(struct thread_pool *pool, int num_threads)
{
    int i;

    // æ£€æŸ¥ num_threads çš„å€¼æ˜¯å¦è¶…è¿‡äº†æœ€å¤§å€¼
    if (num_threads > MAX_ACTIVE_THREADS - pool->active_threads) {
        num_threads = MAX_ACTIVE_THREADS - pool->active_threads;
    }

    // åˆ›å»ºæ–°çº¿ç¨‹
    for (i = 0; i < num_threads; i++) {
        struct thread *thread = (struct thread *)malloc(sizeof(struct thread));

        INIT_LIST_HEAD(&thread->list);
        // ä½¿ç”¨ pthread_create åˆ›å»ºçº¿ç¨‹
        int ret = pthread_create(&thread->id, NULL, thread_pool_main, pool);
		if (ret != 0) {
			perror("create threads error");
			exit(1);
		}

        // å°†æ–°åˆ›å»ºçš„çº¿ç¨‹æ·»åŠ åˆ°çº¿ç¨‹æ± ä¸­
        list_add_tail(&thread->list, &pool->threads);
    }

    // æ›´æ–°çº¿ç¨‹æ± ä¸­çš„æ´»è·ƒçº¿ç¨‹æ•°
    pool->active_threads += num_threads;
}
```

### 2.7 åˆ é™¤çº¿ç¨‹

+ æ¥å£æ–‡æ¡£

| åŸå‹       | void thread_pool_remove_thread(struct thread_pool \*pool, int num_threads); |
| :--------- | :----------------------------------------------------------- |
| åŠŸèƒ½æè¿°   | åˆ é™¤çº¿ç¨‹æ± ä¸­æ´»è·ƒçº¿ç¨‹çš„ä¸ªæ•°                                   |
| å‚æ•°       | pool: éœ€è¦åˆ é™¤çº¿ç¨‹çš„çº¿ç¨‹æ± æŒ‡é’ˆ<br/>num_threads: è¦åˆ é™¤çš„çº¿ç¨‹ä¸ªæ•°ï¼Œè¯¥å‚æ•°è®¾ç½®ä¸º0æ—¶ç›´æ¥è¿”å›å½“å‰çº¿ç¨‹æ± çº¿ç¨‹æ€»æ•°ï¼Œå¯¹çº¿ç¨‹æ± ä¸é€ æˆä»»ä½•å…¶å®ƒå½±å“ |
| è¿”å›å€¼     | æ—                                                            |
| æ‰€åœ¨å¤´æ–‡ä»¶ | thread_pool.h                                                |
| å¤‡æ³¨       | 1ï¼Œçº¿ç¨‹æ± è‡³å°‘ä¼šå­˜åœ¨1æ¡æ´»è·ƒçº¿ç¨‹<br/>2ï¼Œå¦‚æœè¢«åˆ é™¤çš„çº¿ç¨‹æ­£åœ¨æ‰§è¡Œä»»åŠ¡ï¼Œåˆ™å°†ç­‰å¾…å…¶å®Œæˆä»»åŠ¡ä¹‹ååˆ é™¤ |

+ ä»£ç å®ç°

```jsx showLineNumbers
void thread_pool_remove_thread(struct thread_pool *pool, int num_threads)
{
    int i;
    for (i = 0; i < num_threads; i++) {
        // ä»çº¿ç¨‹æ± ä¸­è·å–æœ€åä¸€ä¸ªçº¿ç¨‹
        struct thread *thread = list_last_entry(&pool->threads, struct thread, list);

        // ä½¿ç”¨ pthread_cancel å–æ¶ˆçº¿ç¨‹
        int ret = pthread_cancel(thread->id);
        if (ret != 0) {
            fprintf(stderr, "pthread_cancel failed: %s\n", strerror(ret));
        }

        // æ£€æŸ¥çº¿ç¨‹æ˜¯å¦æ­£åœ¨æ‰§è¡Œä»»åŠ¡
        if (pool->waiting_tasks > 0) {
            // å¦‚æœçº¿ç¨‹æ­£åœ¨æ‰§è¡Œä»»åŠ¡ï¼Œåˆ™ç­‰å¾…å®ƒå®Œæˆ
            pthread_join(thread->id, NULL);
        }

        // ä»çº¿ç¨‹æ± ä¸­åˆ é™¤çº¿ç¨‹
        list_del(&thread->list);
        free(thread);

		// æ›´æ–°çº¿ç¨‹æ± ä¸­çš„çº¿ç¨‹æ•°
        pool->active_threads--;
    }
}
```

### 2.8 é”€æ¯çº¿ç¨‹æ± 

+ æ¥å£æ–‡æ¡£

| åŸå‹       | void thread_pool_destroy(thread_pool \*pool);                |
| :--------- | :----------------------------------------------------------- |
| åŠŸèƒ½æè¿°   | é˜»å¡ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆï¼Œç„¶åç«‹å³é”€æ¯æ•´ä¸ªçº¿ç¨‹æ± ï¼Œé‡Šæ”¾æ‰€æœ‰èµ„æºå’Œå†…å­˜ |
| å‚æ•°       | pool:å°†è¦é”€æ¯çš„çº¿ç¨‹æ±                                         |
| è¿”å›å€¼     | æˆåŠŸè¿”å›trueï¼Œå¤±è´¥è¿”å›false                                  |
| æ‰€åœ¨å¤´æ–‡ä»¶ | thread_pool.h                                                |
| å¤‡æ³¨       | æ—                                                            |

+ ä»£ç å®ç°

```jsx showLineNumbers
void thread_pool_destroy(struct thread_pool *pool)
{
	pool->shutdown = true;	//çº¿ç¨‹æ± çš„é”€æ¯æ ‡è®°
	pthread_cond_broadcast(&pool->cond);	//å”¤é†’æ‰€æœ‰çº¿ç¨‹
	int i;
	// é”€æ¯çº¿ç¨‹æ± ä¸­çš„æ‰€æœ‰çº¿ç¨‹
	for (i = 1; i <= pool->active_threads; i++) {
		struct thread *thread = list_entry(pool->threads.next, struct thread, list);

    	// ä½¿ç”¨ pthread_join ç­‰å¾…çº¿ç¨‹ç»“æŸ
   		int ret = pthread_join(thread->id, NULL);
    	if(ret != 0) {
        	printf("join id[%d] error: %s\n", i, strerror(errno));
    	} else {
        	printf("[%ld] is joined, i=%d\n", thread->id, i);
    	}
   		// ä»çº¿ç¨‹æ± ä¸­åˆ é™¤å·²é€€å‡ºçš„çº¿ç¨‹
    	list_del(&thread->list);
    	free(thread);
	}

	// é‡ç½®ä»»åŠ¡é˜Ÿåˆ—
	INIT_LIST_HEAD(&pool->queue);
	// é”€æ¯é”å’Œæ¡ä»¶å˜é‡
	pthread_mutex_destroy(&pool->lock);
	pthread_cond_destroy(&pool->cond);

	// é‡Šæ”¾çº¿ç¨‹æ± å ç”¨çš„å†…å­˜
	// free(pool);			
}
```

### 2.9 çº¿ç¨‹å…¥å£å‡½æ•°

+ ç”¨æ¥æ‰§è¡Œä»»åŠ¡çš„çº¿ç¨‹å‡½æ•°ï¼š

```jsx showLineNumbers
void *thread_pool_main(void *arg)
{
	struct thread_pool *pool = (struct thread_pool *) arg;
	struct task *task;

	while (1) {
		// è®¿é—®ä»»åŠ¡é˜Ÿåˆ—å‰åŠ é”ï¼Œä¸ºé˜²æ­¢å–æ¶ˆåæ­»é”ï¼Œæ³¨å†Œå¤„ç†ä¾‹ç¨‹ handle
		pthread_cleanup_push(handler, (void *)&pool->lock);	//é˜²æ­¢æ­»é”
		// è·å–é”
		pthread_mutex_lock(&pool->lock);

		// å¦‚æœä»»åŠ¡é˜Ÿåˆ—ä¸ºç©ºï¼Œåˆ™é˜»å¡ç­‰å¾…
		while (list_empty(&pool->queue) && !pool->shutdown) {
			pthread_cond_wait(&pool->cond, &pool->lock);
		}

		//å¦‚æœä»»åŠ¡ä¸ºç©ºï¼Œçº¿ç¨‹æ± è¢«é”€æ¯ï¼Œåˆ™ç«‹å³é‡Šæ”¾äº’æ–¥é”å¹¶é€€å‡º
		if(list_empty(&pool->queue) && pool->shutdown) {
			pthread_mutex_unlock(&pool->lock);
			pthread_exit(NULL);
		}

		// å°†é˜Ÿåˆ—ä¸­çš„ç¬¬ä¸€ä¸ªä»»åŠ¡å–å‡º
		task = list_first_entry(&pool->queue, struct task, list);
		list_del(&task->list);
		pool->waiting_tasks--;	// ä»»åŠ¡æ•°é‡å‡1
		// é‡Šæ”¾é”
		pthread_mutex_unlock(&pool->lock);
		// ä»»åŠ¡å–èµ°ï¼Œè§£é”ï¼Œå¹¶å¼¹æ ˆ handleï¼ˆä½†ä¸æ‰§è¡Œå®ƒï¼‰
		pthread_cleanup_pop(0);

		//æ‰§è¡Œä»»åŠ¡æœŸé—´æ‹’ç»å–æ¶ˆè¯·æ±‚
		pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, NULL);
		task->func(task->arg);	// æ‰§è¡Œä»»åŠ¡
		pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL);

		free(task);	//é‡Šæ”¾èµ„æº
	}
	pthread_exit(NULL);
}
```

+ æ³¨å†Œæ­»é”å¤„ç†å‡½æ•°

```jsx showLineNumbers
static void handler(void *arg)
{
	// å“åº”å–æ¶ˆè¯·æ±‚ä¹‹åè‡ªåŠ¨å¤„ç†ï¼šé‡Šæ”¾äº’æ–¥é”
	pthread_mutex_unlock((pthread_mutex_t *)arg);
}
```



## 3. ä½¿ç”¨ç¤ºä¾‹

```jsx showLineNumbers
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include "thread_pool.h"

// ä»»åŠ¡1
void *task(void *arg)
{
    printf("Task 1 is running...\n");

    // ä»»åŠ¡1ä¼‘çœ ä¸€æ®µæ—¶é—´
    sleep(1);

    printf("Task 1 is done.\n");

    //pthread_exit(NULL);
}

int main(int argc, char *argv[])
{
    // åˆ›å»ºçº¿ç¨‹æ± 
    struct thread_pool pool;
    thread_pool_init(&pool, 4);
printf("å½“å‰çº¿ç¨‹æ•°ä¸ºï¼š%u\n", pool.active_threads);
	sleep(1);

	// åˆ é™¤çº¿ç¨‹
	thread_pool_remove_thread(&pool, 2);
printf("å½“å‰çº¿ç¨‹æ•°ä¸ºï¼š%u\n", pool.active_threads);
	sleep(1);

	// æ·»åŠ çº¿ç¨‹åˆ°çº¿ç¨‹æ± ä¸­
	thread_pool_add_thread(&pool, 3);
printf("å½“å‰çº¿ç¨‹æ•°ä¸ºï¼š%u\n", pool.active_threads);
	sleep(1);

    // æ·»åŠ ä»»åŠ¡åˆ°çº¿ç¨‹æ± ä¸­
    thread_pool_add_task(&pool, task, NULL);
	sleep(1);
    thread_pool_add_task(&pool, task, NULL);
	sleep(1);
    thread_pool_add_task(&pool, task, NULL);
	sleep(1);

    // ä¸»çº¿ç¨‹ä¼‘çœ ä¸€æ®µæ—¶é—´ï¼Œè®©ä»»åŠ¡å®Œæˆ
    sleep(1);
printf("\033[31m""---------Function: [%s]---------Line: [%d]---------\n""\033[m", __FUNCTION__, __LINE__);	
    // æ¸…ç†çº¿ç¨‹æ± 
    thread_pool_destroy(&pool);

printf("\033[31m""---------Function: [%s]---------Line: [%d]---------\n""\033[m", __FUNCTION__, __LINE__);

    return 0;
}
```

## 4. æºç 

æƒ³è¦æºç çš„è¯ï¼Œä¸å¦¨ä¸Šæˆ‘çš„[ğŸGitHub](https://github.com/disnox/thread_pool)çœ‹çœ‹å§ï¼

<!-- truncate -->

